

client.cpp
```cpp
#include"tool.h"
#include<Winsock2.h>
#include<time.h> 
#pragma comment(lib,"ws2_32")
using namespace std;
#define SERVER_PORT 6666

SOCKET localSocket;
struct sockaddr_in serverAddr,clientAddr;//接收端的ip和端口号信息 
DWORD WINAPI handlerRequest(LPVOID lpParam);
DWORD WINAPI handlerTimer(LPVOID lpParam);

bool begin_recv=false;//可以开始接收 
bool waiting=false; //等待发送 
string sendbuf="";
string temp;

int seq_num=0;//序号
clock_t start;
bool begin_timer=false;
 
//发送报文 ，包含[序号$信息$校验和] 
void send_to(string sendbuf){

	//序号
	if(seq_num==0){
		sendbuf="0$"+sendbuf;
	} 
	else{
		sendbuf="1$"+sendbuf;
	}	
	//校验和：校验除了校验和字段外的所有字段 
	unsigned long checksum_seg=checksum(sendbuf);
	sendbuf=sendbuf+"$"+to_string(checksum_seg);
	
	const char *buffer=sendbuf.c_str();
	//发送数据
	sendto(localSocket,buffer,200,0,(SOCKADDR*)&serverAddr,sizeof(SOCKADDR));
	//开始计时
	start=clock(); 
	begin_timer=true;
}

//接收 
string recv_from(){
	char recvbuf[200];
	int size=sizeof(serverAddr);
	recvfrom(localSocket,recvbuf,200,0,(SOCKADDR*)&serverAddr,&size);
	//cout<<"服务器端口号："<<ntohs(serverAddr.sin_port); 
	string s=recvbuf;
	return s;
}

int main(){
	//初始化
    WSADATA wsaData;
	WORD wVersionRequested = MAKEWORD(2,1); 
	WSAStartup(wVersionRequested, &wsaData);

	//去连接服务器的socket
    localSocket=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);
    
    //服务器的ip和端口号 
    serverAddr.sin_family = AF_INET;
	serverAddr.sin_port = htons(6666);
    serverAddr.sin_addr.s_addr = inet_addr("127.0.0.1");
	
	HANDLE hThread=CreateThread(NULL, 0, handlerRequest,LPVOID(), 0,NULL);
	HANDLE hThread2=CreateThread(NULL, 0, handlerTimer,LPVOID(), 0,NULL);
	
	
	cout<<">>>";
	
	
	while(1) {
		cin>>sendbuf;
		Sleep(10);//等待waiting更新 
		//当现在不在停等状态时，允许发送报文 
		if(waiting==false){
			seq_num=!seq_num; //新的报文，序号变化 
			send_to(sendbuf);//发送
						
			temp=sendbuf;//缓存，便于重传 
			waiting=true;
		}
		begin_recv=true;//***可以开始接收服务器端消息啦***
		if(sendbuf=="quit"){
			begin_recv=false;
			break;
		}
	}
	CloseHandle(hThread);
	closesocket(localSocket);
	WSACleanup();
}

//负责接收的线程 
DWORD WINAPI handlerRequest(LPVOID lpParam){
	while(1){
		Sleep(10);//改变begin_recv后，需要等一下再接收，不然会丢掉第一个ACK 
		string recvbuf=recv_from();
		if(begin_recv==false)continue;//还不能接收 
		
		begin_timer=false;//收到ack，停止计时 
		cout<<recvbuf<<endl;
		
		//如果收到ACK的序号正确（和最近发送的序号一致），可以发送下一条 
		if(recvbuf[0]==seq_num+'0'){
			waiting=false;
			cout<<">>>";
		} 
		//如果收到ACK的序号错误，继续等待正确ACK，若超时重传
		else{
			waiting=true; 
		}
		
	} 
}
DWORD WINAPI handlerTimer(LPVOID lpParam){
	double dt;
    clock_t end;
    while(1){
    	end = clock();
    	dt = (double)(end - start);
    	if(begin_timer==true && dt==300 ){
		//如果超过300毫秒，这里必须是==，否则会出现dt>1000的异常情况 
			cout<<"timeout="<<dt<<",resend"<<endl; 
			begin_timer=false;
			send_to(temp);//超时重传
		}
	}
}
```
server.cpp
```cpp
#include"tool.h"
#include<Winsock2.h> 
#pragma comment(lib,"ws2_32")
using namespace std;
#define SERVER_PORT 6666

SOCKET localSocket; 
//发送的ip和端口号信息 
struct sockaddr_in clientAddr,serverAddr;


int send_to(string s){
	const char *c=s.c_str();
	//发送数据到地址serverAddr
	return sendto(localSocket,c,200,0,(SOCKADDR*)&clientAddr,sizeof(SOCKADDR));
}
//解析报文 
string analyse(string recvbuf){
	int n=recvbuf.length();
	char seq_num=recvbuf[0];//第一位是序号
	
	//获得校验和 
	int i=2;
	for(;i<n;++i){
		if(recvbuf[i]=='$'){
			break;
		}
	}
	string checksum_seg=get_substr(recvbuf,i+1,n-1);//校验和字段 
	cout<<"校验和字段："<<checksum_seg<<" ";
	string checksum_result=to_string(checksum(get_substr(recvbuf,0,i-1)));
	cout<<"计算出的校验和："<<checksum_result<<' ';
	
	//手动增加干扰，如果序号为1，那么会推迟1000ms回复 
	if(seq_num=='1'){
		Sleep(1000);
	}
	//如果正确，发送[正确序列号$ACK] 
	if(checksum_seg==checksum_result){
		cout<<"校验和正确"<<endl; 
		if(seq_num=='0')send_to("0$ACK"); 
		else send_to("1$ACK"); 
	}
	//错误则发送[错误序列号$ACK]  
	else{
		cout<<"校验和错误"<<endl; 
		if(seq_num=='0')send_to("1$ACK"); 
		else send_to("0$ACK"); 
	}
	//返回报文段 
	return get_substr(recvbuf,2,i-1);
}

string recv_from(){
	char recvbuf[200];
	int size=sizeof(clientAddr);
	recvfrom(localSocket,recvbuf,200,0,(SOCKADDR*)&clientAddr,&size);
	cout<<recvbuf<<endl;
	string s=recvbuf;
	return analyse(s);
}

int main(){
    WSADATA wsaData;
	WORD wVersionRequested = MAKEWORD(2,1); 
	WSAStartup(wVersionRequested, &wsaData);
	
	//本地socket，只负责接收 
    localSocket=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);
    //服务器的ip和端口号 
    struct sockaddr_in clientAddr,serverAddr;
    serverAddr.sin_family = AF_INET;
	serverAddr.sin_port = htons(6666);//htons把unsigned short类型从主机序转换到网络序
    serverAddr.sin_addr.s_addr = inet_addr("127.0.0.1");
	
	//绑定本地socket和端口号 
	bind(localSocket,(SOCKADDR*)&serverAddr,sizeof(SOCKADDR));
	cout<<"本地端口："<<ntohs(serverAddr.sin_port)<<endl;//ntohs把unsigned short类型从网络序转换到主机序
	int recv_status=0;
	while(1) {
		string recvbuf=recv_from();
		cout<<recvbuf<<endl;
	}
	closesocket(localSocket);
	WSACleanup();
}
```
